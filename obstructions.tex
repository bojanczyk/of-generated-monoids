\section{Obstructions}
\label{sec:obstructions}
If a monoid of functions is orbit-finite, then this has a finite witness, namely the  monoid itself, which can be computed from the generators in case it is orbit-finite. 
The main technical result in this paper is that if a monoid of functions is orbit-infinite, then there is also a finite witness, which we call an obstruction, and define below.

\newcommand{\fsfun}{\underset {\text{fs}} \longrightarrow}
\newcommand{\smallfsfun}{\to_{\text{fs}}}
\begin{definition}[Obstruction]
    Let $Q$ be an orbit-finite set, and let $M$ be a finitely supported  submonoid of $Q \smallfsfun Q$.
    An \emph{obstruction} for $M$ consists of 
    \begin{itemize}
        \item a finite set of atoms $S$ which supports of $M$;
        \item a one-orbit subset $X \subseteq Q$ which is supported by $S$;
        \item a function $f \in M$;
    \end{itemize}
    with the following properties:
    \begin{enumerate}
        \item $f$ is the identity on fresh elements  of  $X$; and 
        \item at least one of the following conditions holds: 
        \begin{enumerate}[(a)]
            \item \label{item:merge-obstruction}
             \textbf{non-injective}: for some $x \neq x' \in X$, $f(x) = f(x')$;
            \item \label{item:lost-atom-obstruction}
            \textbf{lost atom}: for some $x \in X$, there is an atom $a \notin S$ that is in the least support of $x$, but not in the least support of $f(x)$.
            \item \label{item:one-time-move-obstruction} \textbf{one-time move}: for some $x \in X$, $f(x) \neq x$, but $f$ is the identity on fresh elements of the $S$-orbit of $f(x)$.
        \end{enumerate}
    \end{enumerate}
\end{definition}



In the above definition, there is a disjunction between items \ref{item:merge-obstruction}, \ref{item:lost-atom-obstruction}, \ref{item:one-time-move-obstruction}. Depending on which item is satisfied, we will speak of an obstruction of type ``non-injective'', ``lost atom'' or ``one-time move''. In principle, an obstruction could have several types.

The main technical result of this paper will be that obstructions are a necessary and sufficient condition for a monoid being orbit-infinite, as stated in the following theorem. 


\begin{theorem}\label{thm:obstructions-sound-and-complete}
    Let $Q$ be an orbit-finite set, and let $M$ be a finitely supported submonoid of $Q \smallfsfun Q$.
    Then $M$ is not orbit-finite if and only if it has an obstruction.
\end{theorem}

 Before discussing this further, let us give examples  of obstructions.
 

\begin{myexample}[One-time move] In this example, the domain $Q$ is the set $\atoms$ of all atoms, and the monoid consists of all finitely supported permutations. This monoid is orbit-infinite. Indeed, 
a finitely supported permutation can only move finitely many atoms, and the number of atoms moved in an orbit invariant, i.e.~two permutations that move different numbers of atoms are in different orbits.

As we mentioned above, if a monoid is orbit-infinite, then it must have an obstruction. Here is the obstruction, which is of type ``one-time move'' for this example. The support $S$ is empty, the orbit is the full set,  and the function $f$ is a transposition of two atoms $a$ and $b$.
\begin{enumerate}
    \item   The first condition in the definition of an obstruction says  that $f$ is the identity on fresh elements in the $S$-orbit of $x$.  This is indeed the case, since $f$ does not move atoms which have a disjoint support with the support of $f$.
    \item  For second condition, we show that item~\ref{item:one-time-move-obstruction} corresponding to ``one-time move'' is satisfied. The witnessing element $x$ is one of the two atoms $a$ and $b$ that are swapped. The orbit of its image is again the full set,  and we have already argued that $f$ is the identity on fresh elements there.  
\end{enumerate}
Summing up, in this example we have shown an orbit-infinite monoid which contains an obstruction of type ``one-time move''. Let us finish the example by explaining the intuition behind the name. The idea is that if take an $f$ as in the obstruction, and the witnessing argument $x$, then this argument will be moved by $f$, since it is not a fixpoint, but it will not be moved again if apply fresh copies of $f$. 
\end{myexample}

\begin{myexample}
[Merge and lost atom] In this example, we show an obstruction that has two types at once, namely merge and lost atom. In this example, the domain $Q$ is $\atoms + 1$. The monoid consists of functions that map finitely many elements to $1$, and are the identity on the remaining elements. This monoid is isomorphic to the monoid of finite subsets of $\atoms$, with set union being the monoid operation. In particular, this monoid is orbit-infinite. 

Here is an example of an obstruction for this monoid, which has both  types ``non-injective'' and ``lost atom''. The support $S$ is again empty. The set $X$ is the orbit $\atoms$.  The function $f$ maps two atoms $a \neq b$ to the set $1$, and is the identity otherwise. As in the previous example, it is easy to see that this function is the identity on fresh elements of $X$. The function is clearly non-injective on this set, which establishes the obstruction of type ``non-injective''. For the obstruction of type ``lost atom'', we observe that the atom $a$ is lost from the least support when applying $f$ to the argument $a$.
\end{myexample}


The rest of this paper is devoted to proving \cref{thm:obstructions-sound-and-complete}.
We use the name ``soundness'' and ``completeness'' for the two implications in  the theorem, as explained in the following diagram: 
\[
\begin{tikzcd}
\text{not orbit-finite}
\arrow[r, bend left, Rightarrow, "\text{completeness}"]
& 
\text{has an obstruction}
\arrow[l, bend left, Rightarrow, "\text{soundness}"]
\end{tikzcd}
\]


In this section, we prove the easier implication, namely soundness, and we show how the theorem can be applied to decide if a deterministic orbit-finite automaton is equivalent to an orbit-finite monoid.  The completeness part will be proved in Section~\ref{sec:completeness-of-obstructions}.

\subsection{Soundness of obstructions}
\label{sec:soundness-of-obstructions}
We begin by proving soundness of obstructions.
\begin{lemma}[Soundness]
    Let $Q$ be an orbit-finite set, and let $M$ be a finitely supported submonoid of $Q \smallfsfun Q$.
    If $M$ has an obstruction, then it is not orbit-finite.
\end{lemma}
\begin{proof}
Consider an obstruction, which consists of a set $S$, an $S$-orbit $X$, a function $f$, and one or two inputs from $X$, depending on the type of the obstruction (the non-injective type uses two input, and the remaining types use one input).
In the proof, we will show that unbounded size supports are realized by composing many  copies of the function $f$, with each copy obtained by  applying some $S$-permutation to the original function. The following claim shows that functions obtained this way, and their compositions, will fix fresh elements of $X$.

\begin{claim}\label{claim:fixes-fresh-closure-properties}
    Let $X$ be an $S$-orbit. The set of functions which fix fresh elements of $X$ is closed under: (a) applying $S$-permutations; and (b) composing functions. 
\end{claim}
\begin{proof}
    Easy check.
\end{proof}

We will prove that if we take $n$ functions $f_1,\ldots,f_n$ from the $S$-orbitg of $f$,  and these functions  are mutually fresh in the sense that their supports intersect only on atoms from $S$, then by composing them we will get a function that has  support of size at least $n$. This will prove that the monoid has unbounded supports, and therefore it is not orbit-finite. To prove that the support has at least $n$ elements, we will use the following sufficient condition, which only cares about fixpoints of the functions.

\begin{claim}\label{claim:unbounded-supports-criterion}
    Consider a function $f$ and let $X$ be a one-orbit set, such that: 
    \begin{enumerate}
        \item the function $f$ fixes fresh elements of $X$;
        \item there exist  $x_1,\ldots,x_n \in X$ which are not fixed by $f$ such that 
         \begin{align*}
        \sup(x_i) \cap \sup(x_j) \subseteq \sup(X).
        \end{align*}
    \end{enumerate}
    Then the least support of $f$ has at least $n$ atoms. 
\end{claim}
\begin{proof}
    Let $T_i$ be the least support of $x_i$ minus the least support of $X$. By assumption, the sets $T_1,\ldots,T_n$ are pairwise disjoint. To prove the claim, we  will show that each of these sets contains at least one atom from the least support of $f$. 
\end{proof}




\paragraph*{Non-injective.}
We begin with an obstruction of the non-injective type.
Consider such an obstruction, which consists of a support $S$, an orbit $X$, a function $f$, and two inputs $x,x' \in X$ that are mapped by $f$ to the same output. In the $S$-orbit of the triple $(f,x,x')$, we  can find infinitely many triples
    \begin{align*}
    (f_1,x_1,x'_1), (f_2,x_2,x'_2), \ldots
    \end{align*}
which are mutually $S$-fresh in the following sense: 
\begin{align*}
\sup(f_i,x_i,x'_i) \cap \sup(f_j,x_j,x'_j) \subseteq S \qquad \text{for every } i \neq j.
\end{align*}
Thanks to the freshness assumption, we know that if we apply a function $f_i$ to an argument $x_j$ with $j \neq i$, then that argument will be a fixpoint. Similarly, $x'_j$ will be a fixpoint. In particular, if we take the composition $f_1 \cdots f_n$ of the first $n$ functions, then this function will merge the two inputs $x_i$ and $x'_i$ for every $i \in \set{1,\ldots,n}$. This is because the first $i-1$ functions will keep these arguments unchanged, then they will be merged by the $i$-th function, and the merge will persist after that. In particular, at least one of  the arguments $x_i,x'_i \in X$ is not fixed by  the composition $f_1 \cdots f_n$. Furthermore, by \cref{claim:fixes-fresh-closure-properties}, the function $f_1 \cdots f_n$ is fixes fresh elements of $X$. Therefore, we can apply \cref{claim:unbounded-supports-criterion} to conclude that this function has support of size at least $n$. 

\paragraph*{Lost atom.} We now consider an obstruction of type ``lost atom'', which involves a function $f$ together with a single designated input $x$. As in the previous case, consider infinitely many pairs 
\begin{align*}
(f_1,x_1),(f_2,x_2), \ldots 
\end{align*}
from the $S$-orbit of $(f,x)$, which are mutually $S$-fresh. As in the previous case, we know that the composition $f_1 \cdots f_n$ is the identity on fresh elements of $X$. We will show, however, that this composition does not fix the elements $x_1,\ldots,x_n$, and therefore we can apply \cref{claim:unbounded-supports-criterion} to conclude that it has support of size at least $n$. To see this, consider an element $x_i$ with $i \in \set{1,\ldots,n}$. This function is fixed by the first $i-1$ function. Once the $i$-th function is applied, there is some atom $a \not \in S$ that is in the least  support of $x_i$, but is not in the least support of its image $f(x_i)$. Since this atom is $S$-fresh with respect to the remaining functions, it will never reappear in the support after applying them. Therefore, after applying all functions $f_1 \cdots f_n$, the atom $a$ will not be in the least support of the image of $x_i$. In particular, $x_i$ will not be fixed.

\paragraph*{One-time move.} Finally, consider an obstruction of type one-time move, which is witnessed by some function $f$ and some argument $x$. Define $y = f(x)$. As in the previous case, consider infinitely many pairs 
\begin{align*}
(f_1,x_1,y_1),(f_2,x_2,y_2), \ldots 
\end{align*}
in the $S$-orbit of $(f,x,y)$ which are mutually $S$-fresh. 
We know that these functions, and their compositions, fix fresh elements of the orbit $X$. By the definition of a one-time move obstruction, we can also draw a similar conclusion about the $S$-orbit of $y$, call it $Y$. Therefore, using the same argument as in the previous cases, we can conclude if we take the composition $f_1 \cdots f_n$, then it will $x_i$ to $y_i$ for $ \in \set{x_1,\ldots,x_n}$. This is because the first $i-1$ functions will fix $x_i$, the $i$-th one will move it to $y_i$, and the remaining functions will fix $y_i$. (This is the reason why the obstruction is called a one-time move.) Hence, we can apply \cref{claim:unbounded-supports-criterion} to conclude that the support of $f_1 \cdots f_n$ is at least $n$.
\end{proof}

\subsection{Deciding orbit-finiteness}
\label{sec:deciding-monoids}
A corollary of the above theorem is that we can decide if a deterministic orbit-finite automaton is equivalent to an orbit-finite monoid. 

\begin{corollary}
    \label{cor:decide-orbit-finite-submonoids}
    The following problem is decidable: 
    \begin{enumerate}
        \item \textbf{Input.} An orbit-finite set $Q$, and an orbit-finite subset 
        $
        \Sigma \subseteq Q \smallfsfun Q.$
        \item \textbf{Question.} Is the monoid generated by $\Sigma$ orbit-finite?
    \end{enumerate}
\end{corollary}
\begin{proof}
    The algorithm consists of two semi-algorithms. The first semi-algorithm terminates with success if the submonoid is orbit-finite and does not terminate otherwise. The second semi-algorithm does the opposite: it terminates with success if the submonoid is orbit-infinite, and does not terminate otherwise. By running the two semi-algorithms in parallel, we obtain a decision procedure for the problem at hand.
    
    The first semi-algorithm computes the compositions 
    \begin{align*}
    \Sigma_0 \eqdef \emptyset \qquad \Sigma_{n+1} = \Sigma_n \cup \Sigma \cdot \Sigma_n,
    \end{align*}
    and reports success if a stable value 
    \begin{align*}
    \Sigma_n = \Sigma_{n+1}
    \end{align*}
    is reached at some point. This semi-algorithm will report success if the generated monoid is orbit-finite, and otherwise it will not terminate. 
    
    The second semi-algorithm enumerates through all candidates for obstructions, i.e.~pairs consisting of a finitely supported subset $X \subseteq Q$ and a function $f$ generated by $\Sigma$, and it reports success if it finds a candidate which satisfies the two conditions 1 and 2 in the definition of an obstruction. Each such candidate can be represented in finite space, and therefore, one can enumerate through all candidates. The following claim shows that one can check if a candidate is an obstruction.
    
    \begin{claim}
        There is an algorithm which checks if $X$ and $f$ are an obstruction.
    \end{claim}
    \begin{proof}
        We present the algorithm in  pseudo-code, which uses the programming language described in~\cite[Section 11]{bojanczyk_slightly2018}. The salient feature of this programming language is that it allows looping (in parallel) over elements of an orbit-finite set. We omit the semantics of the programming language, which should be clear in the particular code below.   The code uses two sub-procedures, 
    \texttt{dim} and \texttt{sup}, which compute the dimension of a set and its support, both of which can be computed in the programming language.
        \begin{lstlisting}
	def obstruction(X, f):

      def idonfresh(X,f):
         # check if f is the identity on fresh elements of X 
        I = $\emptyset$ # the set of non-fixpoints
        for x in X:
          if f(x) $\neq$ x:
             I = I $\cup$ $\{$x$\}$
        return dim(I) == dim(X)

      # check condition 1 in the definition of an obstruction 
      if !idonfresh(X,f):
        return False # not an obstruction

      # check condition 2 in the definition of an obstruction

      # type (a): non-injective
      for x,x$'$ in X: 
        if f(x) == f(x$'$) 
          return True 
    
      # type (b): lost atom
      for x in X:
        if sup(x) $\setminus$ sup(f(x) $\subsetneq$ sup(X):
          return True 

      # type (c): one-time move
      Y = orbit(f(x), sup(X))  # compute the orbit of f(x)
      if idonfresh(Y,f):
         return True

      # if all three types fail, then not an obstruction
      return False
        \end{lstlisting}
    This program inputs two orbit-finite objects, and returns a Boolean.
    As shown in~\cite[Theorem 11.2]{bojanczyk_slightly2018}, the program above, like any program in its programming language, can be executed in finite time, given a representation of its input. 		
    \end{proof}

    Thanks to the above claim, we can enumerate through all candidates for obstructions, and terminate with success once we find one. This semi-algorithm will terminate with success if and only if the monoid is orbit-infinite, since obstructions are a sound and complete witness for orbit-infinity (\cref{thm:obstructions-sound-and-complete}).
\end{proof}


A further corollary is an algorithm for the problem which was the original motivation for this paper, namely deciding if an automaton is equivalent to a monoid.
\begin{corollary}
    The following problem is decidable: 
    \begin{enumerate}
        \item \textbf{Input.} A deterministic orbit-finite automaton.
        \item \textbf{Question.} Is the underlying language recognised by  an orbit-finite monoid?
    \end{enumerate}
\end{corollary}
\begin{proof}
Let $L \subseteq \Sigma^*$ be the language recognised by the input automaton, and consider the following two equivalence relations on input words:
    \begin{itemize}
        \item In the one-sided congruence, two words $w$ and $w'$ are equivalent if 
        \begin{align*}
        wx \in L \iff w'x \in L \qquad \text{for all } x \in \Sigma^*.
        \end{align*}
        Equivalence classes are states of the minimal deterministic automaton.
        \item In the two-sided congruence, two words $w$ and $w'$ are equivalent if
        \begin{align*}
        ywx \in L \iff yw'x \in L \qquad \text{for all } x,y \in \Sigma^*.
        \end{align*}
        Equivalence classes are states of the minimal  monoid.
    \end{itemize}
    Using a determinisation algorithm, we can compute a minimal deterministic automaton for the language, which has some orbit-finite set of states, call it $Q$. Each input word induces a state transformation of type $Q \to Q$. Essentially by definition,  two words are equivalent under the two-sided congruence if and only if they induce the same state transformation. Therefore, the problem reduces to  deciding if the monoid of possible state transformations is orbit-finite. This monoid is orbit-finitely generated, namely by the state transformations of individual letters (and the empty word). Therefore, we can apply Corollary~\ref{cor:decide-orbit-finite-submonoids} to decide if the monoid is orbit-finite.
\end{proof}
